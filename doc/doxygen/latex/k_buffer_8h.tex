\hypertarget{k_buffer_8h}{}\section{k\+Buffer/k\+Buffer.h File Reference}
\label{k_buffer_8h}\index{k\+Buffer/k\+Buffer.\+h@{k\+Buffer/k\+Buffer.\+h}}


A universal ringbuffer library.  


{\ttfamily \#include $<$stdint.\+h$>$}\\*
Include dependency graph for k\+Buffer.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=171pt]{k_buffer_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=171pt]{k_buffer_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structbuffer__t}{buffer\+\_\+t}
\begin{DoxyCompactList}\small\item\em Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a \hyperlink{structbuffer__t}{buffer\+\_\+t}, and run the neccessary functions with a pointer to your instance. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype}~uint16\+\_\+t\hypertarget{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{}\label{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}

\begin{DoxyCompactList}\small\item\em The datatype of one buffer element. As default, it is an 16 bit unsigned integer. Feel free to change it to your needs. \end{DoxyCompactList}\item 
\#define \hyperlink{k_buffer_8h_a82cc29a07ae3edcaf59d1e15c9ac80cf}{B\+U\+F\+F\+E\+R\+\_\+\+E\+N\+A\+B\+L\+E\+\_\+\+M\+E\+AN}\hypertarget{k_buffer_8h_a82cc29a07ae3edcaf59d1e15c9ac80cf}{}\label{k_buffer_8h_a82cc29a07ae3edcaf59d1e15c9ac80cf}

\begin{DoxyCompactList}\small\item\em Enables mean/ averaging functions. If you uncomment this define, the following functions will be compiled.~\newline
 Only enable it, if buffer\+Datatype is some sort of numeric datatype (integer, float, ...)~\newline
 \hyperlink{k_buffer_8h_a1389f5c08210e077301c35bc3b43f681}{buffer\+Mean()};~\newline
 \hyperlink{k_buffer_8h_a1da694b34c0a52809c923d2d149d1348}{buffer\+Mean\+R\+M\+S()};~\newline
 \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \{ \\*
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a69e32851bd2f089b06555decd80aac1b}{buffer\+OK} = 0, 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a6cca9e2a7ecf10052a07be6c0eb252b5}{buffer\+Memory\+Allocation\+Failed}, 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a5f17467af6ed92f0d7888dcb7feb4002}{buffer\+Empty}, 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6ada11f0b96f4a2a828b511c9f713eaeba}{buffer\+Full}, 
\\*
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a4443de2adc482ee2e06cedc60cd5a299}{buffer\+Not\+Initialized}, 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a0620283513c857f87186899770dd2c2e}{buffer\+Error}
 \}\begin{DoxyCompactList}\small\item\em buffer function return codes \end{DoxyCompactList}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8h_aec18d6ea571b1326dbeb7ca15f4969c0}{buffer\+Init} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, uint16\+\_\+t buffer\+Size)
\begin{DoxyCompactList}\small\item\em init a new buffer This function inits a new \hyperlink{structbuffer__t}{buffer\+\_\+t}.~\newline
 \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8h_a8da8904eb3cb9b87699cf0f45ce5bf51}{buffer\+Init\+Static} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, uint16\+\_\+t buffer\+Size, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} $\ast$buffer\+Array)
\begin{DoxyCompactList}\small\item\em init a new buffer This function inits a new \hyperlink{structbuffer__t}{buffer\+\_\+t}, but doesn\textquotesingle{}t allocate the memory dynamically~\newline
 You\textquotesingle{}ve to provide an array of the datatype and the required length when calling this function.~\newline
 This function might be useful, if you want to save the overhead of the malloc() function~\newline
 \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8h_a8508583be1e356a243b0ce67254c516e}{buffer\+Write\+To\+Index} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, uint16\+\_\+t index, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} data)
\begin{DoxyCompactList}\small\item\em write data to a specific index of the buffer. W\+A\+R\+N\+I\+NG\+: Take care when using this function, it is against the main concept of a ringbuffer \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8h_aa0d7e2a4b6fd3da2822d7f968be74e5c}{buffer\+Read\+From\+Index} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, uint16\+\_\+t index, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} $\ast$data)
\begin{DoxyCompactList}\small\item\em read data from a specifig index of the buffer W\+A\+R\+N\+I\+NG\+: Take care when using this function, it is against the main concept of a ringbuffer \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{k_buffer_8h_a5c599b9386c73ccd7b5eeb25f6cca38e}{buffer\+Is\+Empty} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer)
\begin{DoxyCompactList}\small\item\em Checks, wheter the buffer is empty. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{k_buffer_8h_ac69b8a12a33d0cf0a5dab8feb4f7b020}{buffer\+Is\+Full} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer)
\begin{DoxyCompactList}\small\item\em Checks, wheter the buffer is full. \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8h_a9d6410a89adf65a3ef12340ecb9bbd55}{buffer\+Write} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} data)
\begin{DoxyCompactList}\small\item\em add data to the end of the ringbuffer \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8h_af040a9062bc907adde9517c27c870be5}{buffer\+Write\+Overwrite} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} data)
\begin{DoxyCompactList}\small\item\em Add data to the end of the ringbuffer. If the buffer is full, overwrite the first data. \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8h_a9b80be9033ccd6b5a101f811520ab4cc}{buffer\+Read} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} $\ast$data)
\begin{DoxyCompactList}\small\item\em read data from the beginning of the buffer \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8h_a5ecef1fd460ed9635269abce02be866f}{buffer\+Peek} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} $\ast$data)
\begin{DoxyCompactList}\small\item\em have a look at the next element in the buffer, but do not increase the read pointer \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8h_ac806d926fd21729feb18f8e7738e76b4}{buffer\+Fill} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} data, uint8\+\_\+t silent)
\begin{DoxyCompactList}\small\item\em fill the whole buffer with given dummy data. \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8h_afa8bb2b701cd9b7f871c12e0fabd66e1}{buffer\+Available} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, uint16\+\_\+t $\ast$available)
\begin{DoxyCompactList}\small\item\em return, how many elements are stored and available in the buffer \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8h_a1389f5c08210e077301c35bc3b43f681}{buffer\+Mean} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} $\ast$mean\+Out)
\begin{DoxyCompactList}\small\item\em take the average of the whole buffer \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8h_a1da694b34c0a52809c923d2d149d1348}{buffer\+Mean\+R\+MS} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} $\ast$mean\+Out)
\begin{DoxyCompactList}\small\item\em take the root mean square of the whole buffer \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
A universal ringbuffer library. 

\begin{DoxyAuthor}{Author}
Peter Kappelt 
\end{DoxyAuthor}
\begin{DoxySeeAlso}{See also}
\href{https://github.com/peterkappelt/kBuffer}{\tt https\+://github.\+com/peterkappelt/k\+Buffer} 
\end{DoxySeeAlso}
\begin{DoxyCopyright}{Copyright}
Peter Kappelt 2016; M\+IT License (see L\+I\+C\+E\+N\+S\+E.\+txt in the root of this repository) 
\end{DoxyCopyright}


\subsection{Enumeration Type Documentation}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Status\+\_\+t@{buffer\+Status\+\_\+t}}
\index{buffer\+Status\+\_\+t@{buffer\+Status\+\_\+t}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Status\+\_\+t}{bufferStatus_t}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf buffer\+Status\+\_\+t}}\hypertarget{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{}\label{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}


buffer function return codes 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{buffer\+OK@{buffer\+OK}!k\+Buffer.\+h@{k\+Buffer.\+h}}\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+OK@{buffer\+OK}}\item[{\em 
buffer\+OK\hypertarget{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a69e32851bd2f089b06555decd80aac1b}{}\label{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a69e32851bd2f089b06555decd80aac1b}
}]it seems, as everything worked as expected \index{buffer\+Memory\+Allocation\+Failed@{buffer\+Memory\+Allocation\+Failed}!k\+Buffer.\+h@{k\+Buffer.\+h}}\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Memory\+Allocation\+Failed@{buffer\+Memory\+Allocation\+Failed}}\item[{\em 
buffer\+Memory\+Allocation\+Failed\hypertarget{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a6cca9e2a7ecf10052a07be6c0eb252b5}{}\label{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a6cca9e2a7ecf10052a07be6c0eb252b5}
}]happens while allocating memory,~\newline
there is not enough free memory (-\/$>$malloc failed) \index{buffer\+Empty@{buffer\+Empty}!k\+Buffer.\+h@{k\+Buffer.\+h}}\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Empty@{buffer\+Empty}}\item[{\em 
buffer\+Empty\hypertarget{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a5f17467af6ed92f0d7888dcb7feb4002}{}\label{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a5f17467af6ed92f0d7888dcb7feb4002}
}]happens at reading data,~\newline
buffer is empty and there is no more data to read \index{buffer\+Full@{buffer\+Full}!k\+Buffer.\+h@{k\+Buffer.\+h}}\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Full@{buffer\+Full}}\item[{\em 
buffer\+Full\hypertarget{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6ada11f0b96f4a2a828b511c9f713eaeba}{}\label{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6ada11f0b96f4a2a828b511c9f713eaeba}
}]happens at writing data,~\newline
buffer is full, no more data can be written \index{buffer\+Not\+Initialized@{buffer\+Not\+Initialized}!k\+Buffer.\+h@{k\+Buffer.\+h}}\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Not\+Initialized@{buffer\+Not\+Initialized}}\item[{\em 
buffer\+Not\+Initialized\hypertarget{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a4443de2adc482ee2e06cedc60cd5a299}{}\label{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a4443de2adc482ee2e06cedc60cd5a299}
}]The buffer is not initialized \index{buffer\+Error@{buffer\+Error}!k\+Buffer.\+h@{k\+Buffer.\+h}}\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Error@{buffer\+Error}}\item[{\em 
buffer\+Error\hypertarget{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a0620283513c857f87186899770dd2c2e}{}\label{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6a0620283513c857f87186899770dd2c2e}
}]an error occured, which isn\textquotesingle{}t explained nearer. Have a look at the according function \end{description}
\end{Desc}


\subsection{Function Documentation}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Available@{buffer\+Available}}
\index{buffer\+Available@{buffer\+Available}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Available(buffer\+\_\+t $\ast$buffer, uint16\+\_\+t $\ast$available)}{bufferAvailable(buffer_t *buffer, uint16_t *available)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Available (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{uint16\+\_\+t $\ast$}]{available}
\end{DoxyParamCaption}
)}\hypertarget{k_buffer_8h_afa8bb2b701cd9b7f871c12e0fabd66e1}{}\label{k_buffer_8h_afa8bb2b701cd9b7f871c12e0fabd66e1}


return, how many elements are stored and available in the buffer 


\begin{DoxyParams}{Parameters}
{\em buffer} & pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em available} & pointer to a variable where the number of available elements should be stored \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+OK} & it worked as expected \\
\hline
{\em buffer\+Not\+Initialized} & the buffer wasn\textquotesingle{}t initialized \\
\hline
\end{DoxyRetVals}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Fill@{buffer\+Fill}}
\index{buffer\+Fill@{buffer\+Fill}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Fill(buffer\+\_\+t $\ast$buffer, buffer\+Datatype data, uint8\+\_\+t silent)}{bufferFill(buffer_t *buffer, bufferDatatype data, uint8_t silent)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Fill (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{{\bf buffer\+Datatype}}]{data, }
\item[{uint8\+\_\+t}]{silent}
\end{DoxyParamCaption}
)}\hypertarget{k_buffer_8h_ac806d926fd21729feb18f8e7738e76b4}{}\label{k_buffer_8h_ac806d926fd21729feb18f8e7738e76b4}


fill the whole buffer with given dummy data. 


\begin{DoxyParams}{Parameters}
{\em buffer} & pointer \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em data} & data to fill the buffer with \\
\hline
{\em silent} & if this parameter is 1, the buffer will be filled with data, but the write pointer stays at its current position (usefull, if you take the mean but the buffer is not full yet. You can just prefill it, the mean will be taken with the prefilled values) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+OK} & it worked as expected \\
\hline
{\em buffer\+Not\+Initialized} & the buffer wasn\textquotesingle{}t initialized \\
\hline
\end{DoxyRetVals}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Init@{buffer\+Init}}
\index{buffer\+Init@{buffer\+Init}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Init(buffer\+\_\+t $\ast$buffer, uint16\+\_\+t buffer\+Size)}{bufferInit(buffer_t *buffer, uint16_t bufferSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Init (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{uint16\+\_\+t}]{buffer\+Size}
\end{DoxyParamCaption}
)}\hypertarget{k_buffer_8h_aec18d6ea571b1326dbeb7ca15f4969c0}{}\label{k_buffer_8h_aec18d6ea571b1326dbeb7ca15f4969c0}


init a new buffer This function inits a new \hyperlink{structbuffer__t}{buffer\+\_\+t}.~\newline
 


\begin{DoxyParams}{Parameters}
{\em buffer} & Pointer (\&) to a \hyperlink{structbuffer__t}{buffer\+\_\+t} object. \\
\hline
{\em buffer\+Size} & desired size of the buffer, the total buffer size (e.\+g. length-\/of-\/datatype $\ast$ buffer\+Size) may not exceed 2$^\wedge$16 bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+Memory\+Allocation\+Failed} & The memory allocation with malloc failed. Make sure, you have enough memory available \\
\hline
{\em buffer\+OK} & It seems, like everything went well \\
\hline
\end{DoxyRetVals}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Init\+Static@{buffer\+Init\+Static}}
\index{buffer\+Init\+Static@{buffer\+Init\+Static}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Init\+Static(buffer\+\_\+t $\ast$buffer, uint16\+\_\+t buffer\+Size, buffer\+Datatype $\ast$buffer\+Array)}{bufferInitStatic(buffer_t *buffer, uint16_t bufferSize, bufferDatatype *bufferArray)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Init\+Static (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{uint16\+\_\+t}]{buffer\+Size, }
\item[{{\bf buffer\+Datatype} $\ast$}]{buffer\+Array}
\end{DoxyParamCaption}
)}\hypertarget{k_buffer_8h_a8da8904eb3cb9b87699cf0f45ce5bf51}{}\label{k_buffer_8h_a8da8904eb3cb9b87699cf0f45ce5bf51}


init a new buffer This function inits a new \hyperlink{structbuffer__t}{buffer\+\_\+t}, but doesn\textquotesingle{}t allocate the memory dynamically~\newline
 You\textquotesingle{}ve to provide an array of the datatype and the required length when calling this function.~\newline
 This function might be useful, if you want to save the overhead of the malloc() function~\newline
 


\begin{DoxyParams}{Parameters}
{\em buffer} & Pointer (\&) to a \hyperlink{structbuffer__t}{buffer\+\_\+t} object. \\
\hline
{\em buffer\+Size} & desired size of the buffer, the total buffer size (e.\+g. length-\/of-\/datatype $\ast$ buffer\+Size) may not exceed 2$^\wedge$16 bytes \\
\hline
{\em buffer\+Array} & pointer to a array of the type buffer\+Datatype, which is buffer\+Size elements long \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+OK} & It seems, like everything went well \\
\hline
\end{DoxyRetVals}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Is\+Empty@{buffer\+Is\+Empty}}
\index{buffer\+Is\+Empty@{buffer\+Is\+Empty}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Is\+Empty(buffer\+\_\+t $\ast$buffer)}{bufferIsEmpty(buffer_t *buffer)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t buffer\+Is\+Empty (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer}
\end{DoxyParamCaption}
)}\hypertarget{k_buffer_8h_a5c599b9386c73ccd7b5eeb25f6cca38e}{}\label{k_buffer_8h_a5c599b9386c73ccd7b5eeb25f6cca38e}


Checks, wheter the buffer is empty. 


\begin{DoxyParams}{Parameters}
{\em buffer} & Pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 1} & buffer is empty \\
\hline
{\em 0} & buffer is not empty \\
\hline
\end{DoxyRetVals}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Is\+Full@{buffer\+Is\+Full}}
\index{buffer\+Is\+Full@{buffer\+Is\+Full}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Is\+Full(buffer\+\_\+t $\ast$buffer)}{bufferIsFull(buffer_t *buffer)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t buffer\+Is\+Full (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer}
\end{DoxyParamCaption}
)}\hypertarget{k_buffer_8h_ac69b8a12a33d0cf0a5dab8feb4f7b020}{}\label{k_buffer_8h_ac69b8a12a33d0cf0a5dab8feb4f7b020}


Checks, wheter the buffer is full. 


\begin{DoxyParams}{Parameters}
{\em buffer} & Pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 1} & buffer is full \\
\hline
{\em 0} & buffer is not full \\
\hline
\end{DoxyRetVals}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Mean@{buffer\+Mean}}
\index{buffer\+Mean@{buffer\+Mean}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Mean(buffer\+\_\+t $\ast$buffer, buffer\+Datatype $\ast$mean\+Out)}{bufferMean(buffer_t *buffer, bufferDatatype *meanOut)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Mean (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{{\bf buffer\+Datatype} $\ast$}]{mean\+Out}
\end{DoxyParamCaption}
)}\hypertarget{k_buffer_8h_a1389f5c08210e077301c35bc3b43f681}{}\label{k_buffer_8h_a1389f5c08210e077301c35bc3b43f681}


take the average of the whole buffer 


\begin{DoxyParams}{Parameters}
{\em buffer} & pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em mean\+Out} & pointer to a variable, where the mean will be stored \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+OK} & it worked as expected, the mean is stored at the given variable \\
\hline
{\em buffer\+Not\+Initialized} & the buffer is not initialized \\
\hline
\end{DoxyRetVals}
\begin{DoxyRefDesc}{Bug}
\item[\hyperlink{bug__bug000001}{Bug}]The sum of the buffer is taken. Take precautions, that this variable won\textquotesingle{}t overflow \end{DoxyRefDesc}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Mean\+R\+MS@{buffer\+Mean\+R\+MS}}
\index{buffer\+Mean\+R\+MS@{buffer\+Mean\+R\+MS}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Mean\+R\+M\+S(buffer\+\_\+t $\ast$buffer, buffer\+Datatype $\ast$mean\+Out)}{bufferMeanRMS(buffer_t *buffer, bufferDatatype *meanOut)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Mean\+R\+MS (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{{\bf buffer\+Datatype} $\ast$}]{mean\+Out}
\end{DoxyParamCaption}
)}\hypertarget{k_buffer_8h_a1da694b34c0a52809c923d2d149d1348}{}\label{k_buffer_8h_a1da694b34c0a52809c923d2d149d1348}


take the root mean square of the whole buffer 


\begin{DoxyParams}{Parameters}
{\em buffer} & pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em mean\+Out} & pointer to a variable, where the mean will be stored \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+OK} & it worked as expected, the mean is stored at the given variable \\
\hline
{\em buffer\+Not\+Initialized} & the buffer is not initialized \\
\hline
\end{DoxyRetVals}
\begin{DoxyRefDesc}{Bug}
\item[\hyperlink{bug__bug000002}{Bug}]The sum of squared buffer elements is taken. Take precautions, that this variable won\textquotesingle{}t overflow \end{DoxyRefDesc}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Peek@{buffer\+Peek}}
\index{buffer\+Peek@{buffer\+Peek}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Peek(buffer\+\_\+t $\ast$buffer, buffer\+Datatype $\ast$data)}{bufferPeek(buffer_t *buffer, bufferDatatype *data)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Peek (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{{\bf buffer\+Datatype} $\ast$}]{data}
\end{DoxyParamCaption}
)}\hypertarget{k_buffer_8h_a5ecef1fd460ed9635269abce02be866f}{}\label{k_buffer_8h_a5ecef1fd460ed9635269abce02be866f}


have a look at the next element in the buffer, but do not increase the read pointer 


\begin{DoxyParams}{Parameters}
{\em buffer} & pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em data} & pointer to a variable where data should be stored \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+OK} & it worked as expected \\
\hline
{\em buffer\+Not\+Initialized} & the \hyperlink{k_buffer_8c_aec18d6ea571b1326dbeb7ca15f4969c0}{buffer\+Init()} method hasn\textquotesingle{}t been called or failed before \\
\hline
{\em buffer\+Empty} & the buffer is empty an no more data can be read \\
\hline
\end{DoxyRetVals}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Read@{buffer\+Read}}
\index{buffer\+Read@{buffer\+Read}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Read(buffer\+\_\+t $\ast$buffer, buffer\+Datatype $\ast$data)}{bufferRead(buffer_t *buffer, bufferDatatype *data)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Read (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{{\bf buffer\+Datatype} $\ast$}]{data}
\end{DoxyParamCaption}
)}\hypertarget{k_buffer_8h_a9b80be9033ccd6b5a101f811520ab4cc}{}\label{k_buffer_8h_a9b80be9033ccd6b5a101f811520ab4cc}


read data from the beginning of the buffer 


\begin{DoxyParams}{Parameters}
{\em buffer} & pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em data} & pointer to a variable where data should be stored \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+OK} & it worked as expected \\
\hline
{\em buffer\+Not\+Initialized} & the \hyperlink{k_buffer_8c_aec18d6ea571b1326dbeb7ca15f4969c0}{buffer\+Init()} method hasn\textquotesingle{}t been called or failed before \\
\hline
{\em buffer\+Empty} & the buffer is empty an no more data can be read \\
\hline
\end{DoxyRetVals}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Read\+From\+Index@{buffer\+Read\+From\+Index}}
\index{buffer\+Read\+From\+Index@{buffer\+Read\+From\+Index}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Read\+From\+Index(buffer\+\_\+t $\ast$buffer, uint16\+\_\+t index, buffer\+Datatype $\ast$data)}{bufferReadFromIndex(buffer_t *buffer, uint16_t index, bufferDatatype *data)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Read\+From\+Index (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{uint16\+\_\+t}]{index, }
\item[{{\bf buffer\+Datatype} $\ast$}]{data}
\end{DoxyParamCaption}
)}\hypertarget{k_buffer_8h_aa0d7e2a4b6fd3da2822d7f968be74e5c}{}\label{k_buffer_8h_aa0d7e2a4b6fd3da2822d7f968be74e5c}


read data from a specifig index of the buffer W\+A\+R\+N\+I\+NG\+: Take care when using this function, it is against the main concept of a ringbuffer 


\begin{DoxyParams}{Parameters}
{\em buffer} & Pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em index} & The index, where data should be written.~\newline
It can be in range 0 to length -\/ 1 \\
\hline
{\em data} & Pointer to a variable where the read data should be written to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+OK} & It went successfull \\
\hline
{\em buffer\+Not\+Initialized} & The buffer is not initialized. You have to call buffer\+Init before (or the init failed before) \\
\hline
{\em buffer\+Error} & The desired data index is out of range \\
\hline
\end{DoxyRetVals}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Write@{buffer\+Write}}
\index{buffer\+Write@{buffer\+Write}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Write(buffer\+\_\+t $\ast$buffer, buffer\+Datatype data)}{bufferWrite(buffer_t *buffer, bufferDatatype data)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Write (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{{\bf buffer\+Datatype}}]{data}
\end{DoxyParamCaption}
)}\hypertarget{k_buffer_8h_a9d6410a89adf65a3ef12340ecb9bbd55}{}\label{k_buffer_8h_a9d6410a89adf65a3ef12340ecb9bbd55}


add data to the end of the ringbuffer 


\begin{DoxyParams}{Parameters}
{\em buffer} & pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em data} & data which should be written \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+OK} & it worked as expected \\
\hline
{\em buffer\+Not\+Initialized} & the \hyperlink{k_buffer_8c_aec18d6ea571b1326dbeb7ca15f4969c0}{buffer\+Init()} method hasn\textquotesingle{}t been called or failed before \\
\hline
{\em buffer\+Full} & the buffer is full an no more data can be written \\
\hline
\end{DoxyRetVals}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Write\+Overwrite@{buffer\+Write\+Overwrite}}
\index{buffer\+Write\+Overwrite@{buffer\+Write\+Overwrite}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Write\+Overwrite(buffer\+\_\+t $\ast$buffer, buffer\+Datatype data)}{bufferWriteOverwrite(buffer_t *buffer, bufferDatatype data)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Write\+Overwrite (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{{\bf buffer\+Datatype}}]{data}
\end{DoxyParamCaption}
)}\hypertarget{k_buffer_8h_af040a9062bc907adde9517c27c870be5}{}\label{k_buffer_8h_af040a9062bc907adde9517c27c870be5}


Add data to the end of the ringbuffer. If the buffer is full, overwrite the first data. 


\begin{DoxyParams}{Parameters}
{\em buffer} & pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em data} & data which should be written \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+OK} & it worked as expected \\
\hline
{\em buffer\+Not\+Initialized} & the \hyperlink{k_buffer_8c_aec18d6ea571b1326dbeb7ca15f4969c0}{buffer\+Init()} method hasn\textquotesingle{}t been called or failed before \\
\hline
\end{DoxyRetVals}
\index{k\+Buffer.\+h@{k\+Buffer.\+h}!buffer\+Write\+To\+Index@{buffer\+Write\+To\+Index}}
\index{buffer\+Write\+To\+Index@{buffer\+Write\+To\+Index}!k\+Buffer.\+h@{k\+Buffer.\+h}}
\subsubsection[{\texorpdfstring{buffer\+Write\+To\+Index(buffer\+\_\+t $\ast$buffer, uint16\+\_\+t index, buffer\+Datatype data)}{bufferWriteToIndex(buffer_t *buffer, uint16_t index, bufferDatatype data)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Write\+To\+Index (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{uint16\+\_\+t}]{index, }
\item[{{\bf buffer\+Datatype}}]{data}
\end{DoxyParamCaption}
)}\hypertarget{k_buffer_8h_a8508583be1e356a243b0ce67254c516e}{}\label{k_buffer_8h_a8508583be1e356a243b0ce67254c516e}


write data to a specific index of the buffer. W\+A\+R\+N\+I\+NG\+: Take care when using this function, it is against the main concept of a ringbuffer 


\begin{DoxyParams}{Parameters}
{\em buffer} & Pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em index} & The index, where data should be written.~\newline
It can be in range 0 to length -\/ 1 \\
\hline
{\em data} & The actual data which should be written \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+OK} & It went successfull \\
\hline
{\em buffer\+Not\+Initialized} & The buffer is not initialized. You have to call buffer\+Init before (or the init failed before) \\
\hline
{\em buffer\+Error} & The desired data index is out of range \\
\hline
\end{DoxyRetVals}
