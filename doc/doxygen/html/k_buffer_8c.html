<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>kBuffer: kBuffer/kBuffer.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="kappelt-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">kBuffer
   &#160;<span id="projectnumber">1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2dfe32b6b8cb2579511c610013a95ef9.html">kBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">kBuffer.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A universal ringbuffer library.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="k_buffer_8h_source.html">kBuffer.h</a>&quot;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for kBuffer.c:</div>
<div class="dyncontent">
<div class="center"><img src="k_buffer_8c__incl.png" border="0" usemap="#k_buffer_2k_buffer_8c" alt=""/></div>
<map name="k_buffer_2k_buffer_8c" id="k_buffer_2k_buffer_8c">
<area shape="rect" id="node2" href="k_buffer_8h.html" title="A universal ringbuffer library. " alt="" coords="5,80,80,107"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aec18d6ea571b1326dbeb7ca15f4969c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8c.html#aec18d6ea571b1326dbeb7ca15f4969c0">bufferInit</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, uint16_t bufferSize)</td></tr>
<tr class="memdesc:aec18d6ea571b1326dbeb7ca15f4969c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">init a new buffer This function inits a new <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a>.<br />
  <a href="#aec18d6ea571b1326dbeb7ca15f4969c0">More...</a><br /></td></tr>
<tr class="separator:aec18d6ea571b1326dbeb7ca15f4969c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da8904eb3cb9b87699cf0f45ce5bf51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8c.html#a8da8904eb3cb9b87699cf0f45ce5bf51">bufferInitStatic</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, uint16_t bufferSize, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *bufferArray)</td></tr>
<tr class="memdesc:a8da8904eb3cb9b87699cf0f45ce5bf51"><td class="mdescLeft">&#160;</td><td class="mdescRight">init a new buffer This function inits a new <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a>, but doesn't allocate the memory dynamically<br />
 You've to provide an array of the datatype and the required length when calling this function.<br />
 This function might be useful, if you want to save the overhead of the malloc() function<br />
  <a href="#a8da8904eb3cb9b87699cf0f45ce5bf51">More...</a><br /></td></tr>
<tr class="separator:a8da8904eb3cb9b87699cf0f45ce5bf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8508583be1e356a243b0ce67254c516e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8c.html#a8508583be1e356a243b0ce67254c516e">bufferWriteToIndex</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, uint16_t index, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> data)</td></tr>
<tr class="memdesc:a8508583be1e356a243b0ce67254c516e"><td class="mdescLeft">&#160;</td><td class="mdescRight">write data to a specific index of the buffer. WARNING: Take care when using this function, it is against the main concept of a ringbuffer  <a href="#a8508583be1e356a243b0ce67254c516e">More...</a><br /></td></tr>
<tr class="separator:a8508583be1e356a243b0ce67254c516e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d7e2a4b6fd3da2822d7f968be74e5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8c.html#aa0d7e2a4b6fd3da2822d7f968be74e5c">bufferReadFromIndex</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, uint16_t index, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *data)</td></tr>
<tr class="memdesc:aa0d7e2a4b6fd3da2822d7f968be74e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">read data from a specifig index of the buffer WARNING: Take care when using this function, it is against the main concept of a ringbuffer  <a href="#aa0d7e2a4b6fd3da2822d7f968be74e5c">More...</a><br /></td></tr>
<tr class="separator:aa0d7e2a4b6fd3da2822d7f968be74e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c599b9386c73ccd7b5eeb25f6cca38e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8c.html#a5c599b9386c73ccd7b5eeb25f6cca38e">bufferIsEmpty</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer)</td></tr>
<tr class="memdesc:a5c599b9386c73ccd7b5eeb25f6cca38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks, wheter the buffer is empty.  <a href="#a5c599b9386c73ccd7b5eeb25f6cca38e">More...</a><br /></td></tr>
<tr class="separator:a5c599b9386c73ccd7b5eeb25f6cca38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69b8a12a33d0cf0a5dab8feb4f7b020"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8c.html#ac69b8a12a33d0cf0a5dab8feb4f7b020">bufferIsFull</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer)</td></tr>
<tr class="memdesc:ac69b8a12a33d0cf0a5dab8feb4f7b020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks, wheter the buffer is full.  <a href="#ac69b8a12a33d0cf0a5dab8feb4f7b020">More...</a><br /></td></tr>
<tr class="separator:ac69b8a12a33d0cf0a5dab8feb4f7b020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6410a89adf65a3ef12340ecb9bbd55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8c.html#a9d6410a89adf65a3ef12340ecb9bbd55">bufferWrite</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> data)</td></tr>
<tr class="memdesc:a9d6410a89adf65a3ef12340ecb9bbd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">add data to the end of the ringbuffer  <a href="#a9d6410a89adf65a3ef12340ecb9bbd55">More...</a><br /></td></tr>
<tr class="separator:a9d6410a89adf65a3ef12340ecb9bbd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af040a9062bc907adde9517c27c870be5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8c.html#af040a9062bc907adde9517c27c870be5">bufferWriteOverwrite</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> data)</td></tr>
<tr class="memdesc:af040a9062bc907adde9517c27c870be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to the end of the ringbuffer. If the buffer is full, overwrite the first data.  <a href="#af040a9062bc907adde9517c27c870be5">More...</a><br /></td></tr>
<tr class="separator:af040a9062bc907adde9517c27c870be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b80be9033ccd6b5a101f811520ab4cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8c.html#a9b80be9033ccd6b5a101f811520ab4cc">bufferRead</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *data)</td></tr>
<tr class="memdesc:a9b80be9033ccd6b5a101f811520ab4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">read data from the beginning of the buffer  <a href="#a9b80be9033ccd6b5a101f811520ab4cc">More...</a><br /></td></tr>
<tr class="separator:a9b80be9033ccd6b5a101f811520ab4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac806d926fd21729feb18f8e7738e76b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8c.html#ac806d926fd21729feb18f8e7738e76b4">bufferFill</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> data, uint8_t silent)</td></tr>
<tr class="memdesc:ac806d926fd21729feb18f8e7738e76b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill the whole buffer with given dummy data.  <a href="#ac806d926fd21729feb18f8e7738e76b4">More...</a><br /></td></tr>
<tr class="separator:ac806d926fd21729feb18f8e7738e76b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8bb2b701cd9b7f871c12e0fabd66e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8c.html#afa8bb2b701cd9b7f871c12e0fabd66e1">bufferAvailable</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, uint16_t *available)</td></tr>
<tr class="memdesc:afa8bb2b701cd9b7f871c12e0fabd66e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return, how many elements are stored and available in the buffer  <a href="#afa8bb2b701cd9b7f871c12e0fabd66e1">More...</a><br /></td></tr>
<tr class="separator:afa8bb2b701cd9b7f871c12e0fabd66e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecef1fd460ed9635269abce02be866f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8c.html#a5ecef1fd460ed9635269abce02be866f">bufferPeek</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *data)</td></tr>
<tr class="memdesc:a5ecef1fd460ed9635269abce02be866f"><td class="mdescLeft">&#160;</td><td class="mdescRight">have a look at the next element in the buffer, but do not increase the read pointer  <a href="#a5ecef1fd460ed9635269abce02be866f">More...</a><br /></td></tr>
<tr class="separator:a5ecef1fd460ed9635269abce02be866f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1389f5c08210e077301c35bc3b43f681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8c.html#a1389f5c08210e077301c35bc3b43f681">bufferMean</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *meanOut)</td></tr>
<tr class="memdesc:a1389f5c08210e077301c35bc3b43f681"><td class="mdescLeft">&#160;</td><td class="mdescRight">take the average of the whole buffer  <a href="#a1389f5c08210e077301c35bc3b43f681">More...</a><br /></td></tr>
<tr class="separator:a1389f5c08210e077301c35bc3b43f681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da694b34c0a52809c923d2d149d1348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8c.html#a1da694b34c0a52809c923d2d149d1348">bufferMeanRMS</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *meanOut)</td></tr>
<tr class="memdesc:a1da694b34c0a52809c923d2d149d1348"><td class="mdescLeft">&#160;</td><td class="mdescRight">take the root mean square of the whole buffer  <a href="#a1da694b34c0a52809c923d2d149d1348">More...</a><br /></td></tr>
<tr class="separator:a1da694b34c0a52809c923d2d149d1348"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A universal ringbuffer library. </p>
<dl class="section author"><dt>Author</dt><dd>Peter Kappelt </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/peterkappelt/kBuffer">https://github.com/peterkappelt/kBuffer</a> </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Peter Kappelt 2016; MIT License (see LICENSE.txt in the root of this repository) </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="afa8bb2b701cd9b7f871c12e0fabd66e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return, how many elements are stored and available in the buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">available</td><td>pointer to a variable where the number of available elements should be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>it worked as expected </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>the buffer wasn't initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac806d926fd21729feb18f8e7738e76b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferFill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>silent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fill the whole buffer with given dummy data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">data</td><td>data to fill the buffer with </td></tr>
    <tr><td class="paramname">silent</td><td>if this parameter is 1, the buffer will be filled with data, but the write pointer stays at its current position (usefull, if you take the mean but the buffer is not full yet. You can just prefill it, the mean will be taken with the prefilled values) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>it worked as expected </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>the buffer wasn't initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec18d6ea571b1326dbeb7ca15f4969c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>init a new buffer This function inits a new <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a>.<br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer (&amp;) to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> object. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>desired size of the buffer, the total buffer size (e.g. length-of-datatype * bufferSize) may not exceed 2^16 bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferMemoryAllocationFailed</td><td>The memory allocation with malloc failed. Make sure, you have enough memory available </td></tr>
    <tr><td class="paramname">bufferOK</td><td>It seems, like everything went well </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8da8904eb3cb9b87699cf0f45ce5bf51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferInitStatic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *&#160;</td>
          <td class="paramname"><em>bufferArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>init a new buffer This function inits a new <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a>, but doesn't allocate the memory dynamically<br />
 You've to provide an array of the datatype and the required length when calling this function.<br />
 This function might be useful, if you want to save the overhead of the malloc() function<br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer (&amp;) to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> object. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>desired size of the buffer, the total buffer size (e.g. length-of-datatype * bufferSize) may not exceed 2^16 bytes </td></tr>
    <tr><td class="paramname">bufferArray</td><td>pointer to a array of the type bufferDatatype, which is bufferSize elements long </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>It seems, like everything went well </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c599b9386c73ccd7b5eeb25f6cca38e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bufferIsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks, wheter the buffer is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>buffer is empty </td></tr>
    <tr><td class="paramname">0</td><td>buffer is not empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac69b8a12a33d0cf0a5dab8feb4f7b020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bufferIsFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks, wheter the buffer is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>buffer is full </td></tr>
    <tr><td class="paramname">0</td><td>buffer is not full </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1389f5c08210e077301c35bc3b43f681"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferMean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *&#160;</td>
          <td class="paramname"><em>meanOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take the average of the whole buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">meanOut</td><td>pointer to a variable, where the mean will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>it worked as expected, the mean is stored at the given variable </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>the buffer is not initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>The sum of the buffer is taken. Take precautions, that this variable won't overflow </dd></dl>

</div>
</div>
<a class="anchor" id="a1da694b34c0a52809c923d2d149d1348"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferMeanRMS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *&#160;</td>
          <td class="paramname"><em>meanOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take the root mean square of the whole buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">meanOut</td><td>pointer to a variable, where the mean will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>it worked as expected, the mean is stored at the given variable </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>the buffer is not initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>The sum of squared buffer elements is taken. Take precautions, that this variable won't overflow </dd></dl>

</div>
</div>
<a class="anchor" id="a5ecef1fd460ed9635269abce02be866f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferPeek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>have a look at the next element in the buffer, but do not increase the read pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">data</td><td>pointer to a variable where data should be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>it worked as expected </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>the <a class="el" href="k_buffer_8c.html#aec18d6ea571b1326dbeb7ca15f4969c0" title="init a new buffer This function inits a new buffer_t.  ">bufferInit()</a> method hasn't been called or failed before </td></tr>
    <tr><td class="paramname">bufferEmpty</td><td>the buffer is empty an no more data can be read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b80be9033ccd6b5a101f811520ab4cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read data from the beginning of the buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">data</td><td>pointer to a variable where data should be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>it worked as expected </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>the <a class="el" href="k_buffer_8c.html#aec18d6ea571b1326dbeb7ca15f4969c0" title="init a new buffer This function inits a new buffer_t.  ">bufferInit()</a> method hasn't been called or failed before </td></tr>
    <tr><td class="paramname">bufferEmpty</td><td>the buffer is empty an no more data can be read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0d7e2a4b6fd3da2822d7f968be74e5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferReadFromIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read data from a specifig index of the buffer WARNING: Take care when using this function, it is against the main concept of a ringbuffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">index</td><td>The index, where data should be written.<br />
It can be in range 0 to length - 1 </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to a variable where the read data should be written to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>It went successfull </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>The buffer is not initialized. You have to call bufferInit before (or the init failed before) </td></tr>
    <tr><td class="paramname">bufferError</td><td>The desired data index is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d6410a89adf65a3ef12340ecb9bbd55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add data to the end of the ringbuffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">data</td><td>data which should be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>it worked as expected </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>the <a class="el" href="k_buffer_8c.html#aec18d6ea571b1326dbeb7ca15f4969c0" title="init a new buffer This function inits a new buffer_t.  ">bufferInit()</a> method hasn't been called or failed before </td></tr>
    <tr><td class="paramname">bufferFull</td><td>the buffer is full an no more data can be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af040a9062bc907adde9517c27c870be5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferWriteOverwrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add data to the end of the ringbuffer. If the buffer is full, overwrite the first data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">data</td><td>data which should be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>it worked as expected </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>the <a class="el" href="k_buffer_8c.html#aec18d6ea571b1326dbeb7ca15f4969c0" title="init a new buffer This function inits a new buffer_t.  ">bufferInit()</a> method hasn't been called or failed before </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8508583be1e356a243b0ce67254c516e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferWriteToIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write data to a specific index of the buffer. WARNING: Take care when using this function, it is against the main concept of a ringbuffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">index</td><td>The index, where data should be written.<br />
It can be in range 0 to length - 1 </td></tr>
    <tr><td class="paramname">data</td><td>The actual data which should be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>It went successfull </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>The buffer is not initialized. You have to call bufferInit before (or the init failed before) </td></tr>
    <tr><td class="paramname">bufferError</td><td>The desired data index is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
