<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>kBuffer: kBuffer/kBuffer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="kappelt-logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">kBuffer
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2dfe32b6b8cb2579511c610013a95ef9.html">kBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">kBuffer.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A universal ringbuffer library.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for kBuffer.h:</div>
<div class="dyncontent">
<div class="center"><img src="k_buffer_8h__incl.png" border="0" usemap="#k_buffer_2k_buffer_8h" alt=""/></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="k_buffer_8h__dep__incl.png" border="0" usemap="#k_buffer_2k_buffer_8hdep" alt=""/></div>
<map name="k_buffer_2k_buffer_8hdep" id="k_buffer_2k_buffer_8hdep">
<area shape="rect" id="node2" href="k_buffer_8c.html" title="A universal ringbuffer library. " alt="" coords="5,80,127,107"/></map>
</div>
</div>
<p><a href="k_buffer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuffer__t.html">buffer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a>, and run the neccessary functions with a pointer to your instance.  <a href="structbuffer__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae8d6ebfbda34ebc2e00138c04b46e9b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8d6ebfbda34ebc2e00138c04b46e9b1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a>&#160;&#160;&#160;uint16_t</td></tr>
<tr class="memdesc:ae8d6ebfbda34ebc2e00138c04b46e9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The datatype of one buffer element. As default, it is an 16 bit unsigned integer. Feel free to change it to your needs. <br /></td></tr>
<tr class="separator:ae8d6ebfbda34ebc2e00138c04b46e9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cc29a07ae3edcaf59d1e15c9ac80cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82cc29a07ae3edcaf59d1e15c9ac80cf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8h.html#a82cc29a07ae3edcaf59d1e15c9ac80cf">BUFFER_ENABLE_MEAN</a></td></tr>
<tr class="memdesc:a82cc29a07ae3edcaf59d1e15c9ac80cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables mean/ averaging functions. If you uncomment this define, the following functions will be compiled.<br />
 Only enable it, if bufferDatatype is some sort of numeric datatype (integer, float, ...)<br />
 <a class="el" href="k_buffer_8h.html#a1389f5c08210e077301c35bc3b43f681" title="take the average of the whole buffer ">bufferMean()</a>;<br />
 <a class="el" href="k_buffer_8h.html#a1da694b34c0a52809c923d2d149d1348" title="take the root mean square of the whole buffer ">bufferMeanRMS()</a>;<br />
 <br /></td></tr>
<tr class="separator:a82cc29a07ae3edcaf59d1e15c9ac80cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7a0bf550b7bd49d85172e409c0034fe6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> { <br />
&#160;&#160;<a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6a69e32851bd2f089b06555decd80aac1b">bufferOK</a> = 0, 
<a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6a6cca9e2a7ecf10052a07be6c0eb252b5">bufferMemoryAllocationFailed</a>, 
<a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6a5f17467af6ed92f0d7888dcb7feb4002">bufferEmpty</a>, 
<a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6ada11f0b96f4a2a828b511c9f713eaeba">bufferFull</a>, 
<br />
&#160;&#160;<a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6a4443de2adc482ee2e06cedc60cd5a299">bufferNotInitialized</a>, 
<a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6a0620283513c857f87186899770dd2c2e">bufferError</a>
<br />
 }</td></tr>
<tr class="memdesc:a7a0bf550b7bd49d85172e409c0034fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer function return codes  <a href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">More...</a><br /></td></tr>
<tr class="separator:a7a0bf550b7bd49d85172e409c0034fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aec18d6ea571b1326dbeb7ca15f4969c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8h.html#aec18d6ea571b1326dbeb7ca15f4969c0">bufferInit</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, uint16_t bufferSize)</td></tr>
<tr class="memdesc:aec18d6ea571b1326dbeb7ca15f4969c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">init a new buffer This function inits a new <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a>.<br />
  <a href="#aec18d6ea571b1326dbeb7ca15f4969c0">More...</a><br /></td></tr>
<tr class="separator:aec18d6ea571b1326dbeb7ca15f4969c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8508583be1e356a243b0ce67254c516e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8h.html#a8508583be1e356a243b0ce67254c516e">bufferWriteToIndex</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, uint16_t index, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> data)</td></tr>
<tr class="memdesc:a8508583be1e356a243b0ce67254c516e"><td class="mdescLeft">&#160;</td><td class="mdescRight">write data to a specific index of the buffer. WARNING: Take care when using this function, it is against the main concept of a ringbuffer  <a href="#a8508583be1e356a243b0ce67254c516e">More...</a><br /></td></tr>
<tr class="separator:a8508583be1e356a243b0ce67254c516e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d7e2a4b6fd3da2822d7f968be74e5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8h.html#aa0d7e2a4b6fd3da2822d7f968be74e5c">bufferReadFromIndex</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, uint16_t index, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *data)</td></tr>
<tr class="memdesc:aa0d7e2a4b6fd3da2822d7f968be74e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">read data from a specifig index of the buffer WARNING: Take care when using this function, it is against the main concept of a ringbuffer  <a href="#aa0d7e2a4b6fd3da2822d7f968be74e5c">More...</a><br /></td></tr>
<tr class="separator:aa0d7e2a4b6fd3da2822d7f968be74e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c599b9386c73ccd7b5eeb25f6cca38e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8h.html#a5c599b9386c73ccd7b5eeb25f6cca38e">bufferIsEmpty</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer)</td></tr>
<tr class="memdesc:a5c599b9386c73ccd7b5eeb25f6cca38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks, wheter the buffer is empty.  <a href="#a5c599b9386c73ccd7b5eeb25f6cca38e">More...</a><br /></td></tr>
<tr class="separator:a5c599b9386c73ccd7b5eeb25f6cca38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69b8a12a33d0cf0a5dab8feb4f7b020"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8h.html#ac69b8a12a33d0cf0a5dab8feb4f7b020">bufferIsFull</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer)</td></tr>
<tr class="memdesc:ac69b8a12a33d0cf0a5dab8feb4f7b020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks, wheter the buffer is full.  <a href="#ac69b8a12a33d0cf0a5dab8feb4f7b020">More...</a><br /></td></tr>
<tr class="separator:ac69b8a12a33d0cf0a5dab8feb4f7b020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6410a89adf65a3ef12340ecb9bbd55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8h.html#a9d6410a89adf65a3ef12340ecb9bbd55">bufferWrite</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> data)</td></tr>
<tr class="memdesc:a9d6410a89adf65a3ef12340ecb9bbd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">add data to the end of the ringbuffer  <a href="#a9d6410a89adf65a3ef12340ecb9bbd55">More...</a><br /></td></tr>
<tr class="separator:a9d6410a89adf65a3ef12340ecb9bbd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b80be9033ccd6b5a101f811520ab4cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8h.html#a9b80be9033ccd6b5a101f811520ab4cc">bufferRead</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *data)</td></tr>
<tr class="memdesc:a9b80be9033ccd6b5a101f811520ab4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">read data from the beginning of the buffer  <a href="#a9b80be9033ccd6b5a101f811520ab4cc">More...</a><br /></td></tr>
<tr class="separator:a9b80be9033ccd6b5a101f811520ab4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac806d926fd21729feb18f8e7738e76b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8h.html#ac806d926fd21729feb18f8e7738e76b4">bufferFill</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> data, uint8_t silent)</td></tr>
<tr class="memdesc:ac806d926fd21729feb18f8e7738e76b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill the whole buffer with given dummy data.  <a href="#ac806d926fd21729feb18f8e7738e76b4">More...</a><br /></td></tr>
<tr class="separator:ac806d926fd21729feb18f8e7738e76b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1389f5c08210e077301c35bc3b43f681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8h.html#a1389f5c08210e077301c35bc3b43f681">bufferMean</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *meanOut)</td></tr>
<tr class="memdesc:a1389f5c08210e077301c35bc3b43f681"><td class="mdescLeft">&#160;</td><td class="mdescRight">take the average of the whole buffer  <a href="#a1389f5c08210e077301c35bc3b43f681">More...</a><br /></td></tr>
<tr class="separator:a1389f5c08210e077301c35bc3b43f681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da694b34c0a52809c923d2d149d1348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k_buffer_8h.html#a1da694b34c0a52809c923d2d149d1348">bufferMeanRMS</a> (<a class="el" href="structbuffer__t.html">buffer_t</a> *buffer, <a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *meanOut)</td></tr>
<tr class="memdesc:a1da694b34c0a52809c923d2d149d1348"><td class="mdescLeft">&#160;</td><td class="mdescRight">take the root mean square of the whole buffer  <a href="#a1da694b34c0a52809c923d2d149d1348">More...</a><br /></td></tr>
<tr class="separator:a1da694b34c0a52809c923d2d149d1348"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A universal ringbuffer library. </p>
<dl class="section author"><dt>Author</dt><dd>Peter Kappelt </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/peterkappelt/kBuffer">https://github.com/peterkappelt/kBuffer</a> </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Peter Kappelt 2016; MIT License (see LICENSE.txt in the root of this repository) </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a7a0bf550b7bd49d85172e409c0034fe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buffer function return codes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7a0bf550b7bd49d85172e409c0034fe6a69e32851bd2f089b06555decd80aac1b"></a>bufferOK&#160;</td><td class="fielddoc">
<p>it seems, as everything worked as expected </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a0bf550b7bd49d85172e409c0034fe6a6cca9e2a7ecf10052a07be6c0eb252b5"></a>bufferMemoryAllocationFailed&#160;</td><td class="fielddoc">
<p>happens while allocating memory,<br />
there is not enough free memory (-&gt;malloc failed) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a0bf550b7bd49d85172e409c0034fe6a5f17467af6ed92f0d7888dcb7feb4002"></a>bufferEmpty&#160;</td><td class="fielddoc">
<p>happens at reading data,<br />
buffer is empty and there is no more data to read </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a0bf550b7bd49d85172e409c0034fe6ada11f0b96f4a2a828b511c9f713eaeba"></a>bufferFull&#160;</td><td class="fielddoc">
<p>happens at writing data,<br />
buffer is full, no more data can be written </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a0bf550b7bd49d85172e409c0034fe6a4443de2adc482ee2e06cedc60cd5a299"></a>bufferNotInitialized&#160;</td><td class="fielddoc">
<p>The buffer is not initialized </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a0bf550b7bd49d85172e409c0034fe6a0620283513c857f87186899770dd2c2e"></a>bufferError&#160;</td><td class="fielddoc">
<p>an error occured, which isn't explained nearer. Have a look at the according function </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac806d926fd21729feb18f8e7738e76b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferFill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>silent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fill the whole buffer with given dummy data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">data</td><td>data to fill the buffer with </td></tr>
    <tr><td class="paramname">silent</td><td>if this parameter is 1, the buffer will be filled with data, but the write pointer stays at its current position (usefull, if you take the mean but the buffer is not full yet. You can just prefill it, the mean will be taken with the prefilled values) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>it worked as expected </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>the buffer wasn't initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec18d6ea571b1326dbeb7ca15f4969c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>init a new buffer This function inits a new <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a>.<br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer (&amp;) to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> object. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>desired size of the buffer, the total buffer size (e.g. length-of-datatype * bufferSize) may not exceed 2^16 bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferMemoryAllocationFailed</td><td>The memory allocation with malloc failed. Make sure, you have enough memory available </td></tr>
    <tr><td class="paramname">bufferOK</td><td>It seems, like everything went well </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c599b9386c73ccd7b5eeb25f6cca38e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bufferIsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks, wheter the buffer is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>buffer is empty </td></tr>
    <tr><td class="paramname">0</td><td>buffer is not empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac69b8a12a33d0cf0a5dab8feb4f7b020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bufferIsFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks, wheter the buffer is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>buffer is full </td></tr>
    <tr><td class="paramname">0</td><td>buffer is not full </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1389f5c08210e077301c35bc3b43f681"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferMean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *&#160;</td>
          <td class="paramname"><em>meanOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take the average of the whole buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">meanOut</td><td>pointer to a variable, where the mean will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>it worked as expected, the mean is stored at the given variable </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>the buffer is not initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>The sum of the buffer is taken. Take precautions, that this variable won't overflow </dd></dl>

</div>
</div>
<a class="anchor" id="a1da694b34c0a52809c923d2d149d1348"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferMeanRMS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *&#160;</td>
          <td class="paramname"><em>meanOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take the root mean square of the whole buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">meanOut</td><td>pointer to a variable, where the mean will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>it worked as expected, the mean is stored at the given variable </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>the buffer is not initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>The sum of squared buffer elements is taken. Take precautions, that this variable won't overflow </dd></dl>

</div>
</div>
<a class="anchor" id="a9b80be9033ccd6b5a101f811520ab4cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read data from the beginning of the buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">data</td><td>pointer to a variable where data should be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>it worked as expected </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>the <a class="el" href="k_buffer_8c.html#aec18d6ea571b1326dbeb7ca15f4969c0" title="init a new buffer This function inits a new buffer_t.  ">bufferInit()</a> method hasn't been called or failed before </td></tr>
    <tr><td class="paramname">bufferEmpty</td><td>the buffer is empty an no more data can be read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0d7e2a4b6fd3da2822d7f968be74e5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferReadFromIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read data from a specifig index of the buffer WARNING: Take care when using this function, it is against the main concept of a ringbuffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">index</td><td>The index, where data should be written.<br />
It can be in range 0 to length - 1 </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to a variable where the read data should be written to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>It went successfull </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>The buffer is not initialized. You have to call bufferInit before (or the init failed before) </td></tr>
    <tr><td class="paramname">bufferError</td><td>The desired data index is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d6410a89adf65a3ef12340ecb9bbd55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add data to the end of the ringbuffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">data</td><td>data which should be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>it worked as expected </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>the <a class="el" href="k_buffer_8c.html#aec18d6ea571b1326dbeb7ca15f4969c0" title="init a new buffer This function inits a new buffer_t.  ">bufferInit()</a> method hasn't been called or failed before </td></tr>
    <tr><td class="paramname">bufferFull</td><td>the buffer is full an no more data can be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8508583be1e356a243b0ce67254c516e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6">bufferStatus_t</a> bufferWriteToIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="k_buffer_8h.html#ae8d6ebfbda34ebc2e00138c04b46e9b1">bufferDatatype</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write data to a specific index of the buffer. WARNING: Take care when using this function, it is against the main concept of a ringbuffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to a <a class="el" href="structbuffer__t.html" title="Struct for buffer handling. If you need a ringbuffer in your software, you should instantiate a buffe...">buffer_t</a> instance </td></tr>
    <tr><td class="paramname">index</td><td>The index, where data should be written.<br />
It can be in range 0 to length - 1 </td></tr>
    <tr><td class="paramname">data</td><td>The actual data which should be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an element of <a class="el" href="k_buffer_8h.html#a7a0bf550b7bd49d85172e409c0034fe6" title="buffer function return codes ">bufferStatus_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bufferOK</td><td>It went successfull </td></tr>
    <tr><td class="paramname">bufferNotInitialized</td><td>The buffer is not initialized. You have to call bufferInit before (or the init failed before) </td></tr>
    <tr><td class="paramname">bufferError</td><td>The desired data index is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
