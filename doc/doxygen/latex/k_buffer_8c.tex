\hypertarget{k_buffer_8c}{}\section{k\+Buffer/k\+Buffer.c File Reference}
\label{k_buffer_8c}\index{k\+Buffer/k\+Buffer.\+c@{k\+Buffer/k\+Buffer.\+c}}


A universal ringbuffer library.  


{\ttfamily \#include \char`\"{}k\+Buffer.\+h\char`\"{}}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$math.\+h$>$}\\*
Include dependency graph for k\+Buffer.\+c\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=268pt]{k_buffer_8c__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8c_aec18d6ea571b1326dbeb7ca15f4969c0}{buffer\+Init} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, uint16\+\_\+t buffer\+Size)
\begin{DoxyCompactList}\small\item\em init a new buffer This function inits a new \hyperlink{structbuffer__t}{buffer\+\_\+t}.~\newline
 \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8c_a8508583be1e356a243b0ce67254c516e}{buffer\+Write\+To\+Index} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, uint16\+\_\+t index, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} data)
\begin{DoxyCompactList}\small\item\em write data to a specific index of the buffer. W\+A\+R\+N\+I\+N\+G\+: Take care when using this function, it is against the main concept of a ringbuffer \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8c_aa0d7e2a4b6fd3da2822d7f968be74e5c}{buffer\+Read\+From\+Index} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, uint16\+\_\+t index, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} $\ast$data)
\begin{DoxyCompactList}\small\item\em read data from a specifig index of the buffer W\+A\+R\+N\+I\+N\+G\+: Take care when using this function, it is against the main concept of a ringbuffer \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{k_buffer_8c_a5c599b9386c73ccd7b5eeb25f6cca38e}{buffer\+Is\+Empty} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer)
\begin{DoxyCompactList}\small\item\em Checks, wheter the buffer is empty. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{k_buffer_8c_ac69b8a12a33d0cf0a5dab8feb4f7b020}{buffer\+Is\+Full} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer)
\begin{DoxyCompactList}\small\item\em Checks, wheter the buffer is full. \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8c_a9d6410a89adf65a3ef12340ecb9bbd55}{buffer\+Write} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} data)
\begin{DoxyCompactList}\small\item\em add data to the end of the ringbuffer \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8c_a9b80be9033ccd6b5a101f811520ab4cc}{buffer\+Read} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} $\ast$data)
\begin{DoxyCompactList}\small\item\em read data from the beginning of the buffer \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8c_ac806d926fd21729feb18f8e7738e76b4}{buffer\+Fill} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} data, uint8\+\_\+t silent)
\begin{DoxyCompactList}\small\item\em fill the whole buffer with given dummy data. \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8c_a1389f5c08210e077301c35bc3b43f681}{buffer\+Mean} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} $\ast$mean\+Out)
\begin{DoxyCompactList}\small\item\em take the average of the whole buffer \end{DoxyCompactList}\item 
\hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} \hyperlink{k_buffer_8c_a1da694b34c0a52809c923d2d149d1348}{buffer\+Mean\+R\+M\+S} (\hyperlink{structbuffer__t}{buffer\+\_\+t} $\ast$buffer, \hyperlink{k_buffer_8h_ae8d6ebfbda34ebc2e00138c04b46e9b1}{buffer\+Datatype} $\ast$mean\+Out)
\begin{DoxyCompactList}\small\item\em take the root mean square of the whole buffer \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
A universal ringbuffer library. 

\begin{DoxyAuthor}{Author}
Peter Kappelt 
\end{DoxyAuthor}
\begin{DoxySeeAlso}{See also}
\href{https://github.com/peterkappelt/kBuffer}{\tt https\+://github.\+com/peterkappelt/k\+Buffer} 
\end{DoxySeeAlso}
\begin{DoxyCopyright}{Copyright}
Peter Kappelt 2016; M\+I\+T License (see L\+I\+C\+E\+N\+S\+E.\+txt in the root of this repository) 
\end{DoxyCopyright}


\subsection{Function Documentation}
\hypertarget{k_buffer_8c_ac806d926fd21729feb18f8e7738e76b4}{}\index{k\+Buffer.\+c@{k\+Buffer.\+c}!buffer\+Fill@{buffer\+Fill}}
\index{buffer\+Fill@{buffer\+Fill}!k\+Buffer.\+c@{k\+Buffer.\+c}}
\subsubsection[{buffer\+Fill}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Fill (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{{\bf buffer\+Datatype}}]{data, }
\item[{uint8\+\_\+t}]{silent}
\end{DoxyParamCaption}
)}\label{k_buffer_8c_ac806d926fd21729feb18f8e7738e76b4}


fill the whole buffer with given dummy data. 


\begin{DoxyParams}{Parameters}
{\em buffer} & pointer \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em data} & data to fill the buffer with \\
\hline
{\em silent} & if this parameter is 1, the buffer will be filled with data, but the write pointer stays at its current position (usefull, if you take the mean but the buffer is not full yet. You can just prefill it, the mean will be taken with the prefilled values) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+O\+K} & it worked as expected \\
\hline
{\em buffer\+Not\+Initialized} & the buffer wasn\textquotesingle{}t initialized \\
\hline
\end{DoxyRetVals}
\hypertarget{k_buffer_8c_aec18d6ea571b1326dbeb7ca15f4969c0}{}\index{k\+Buffer.\+c@{k\+Buffer.\+c}!buffer\+Init@{buffer\+Init}}
\index{buffer\+Init@{buffer\+Init}!k\+Buffer.\+c@{k\+Buffer.\+c}}
\subsubsection[{buffer\+Init}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Init (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{uint16\+\_\+t}]{buffer\+Size}
\end{DoxyParamCaption}
)}\label{k_buffer_8c_aec18d6ea571b1326dbeb7ca15f4969c0}


init a new buffer This function inits a new \hyperlink{structbuffer__t}{buffer\+\_\+t}.~\newline
 


\begin{DoxyParams}{Parameters}
{\em buffer} & Pointer (\&) to a \hyperlink{structbuffer__t}{buffer\+\_\+t} object. \\
\hline
{\em buffer\+Size} & desired size of the buffer, the total buffer size (e.\+g. length-\/of-\/datatype $\ast$ buffer\+Size) may not exceed 2$^\wedge$16 bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+Memory\+Allocation\+Failed} & The memory allocation with malloc failed. Make sure, you have enough memory available \\
\hline
{\em buffer\+O\+K} & It seems, like everything went well \\
\hline
\end{DoxyRetVals}
\hypertarget{k_buffer_8c_a5c599b9386c73ccd7b5eeb25f6cca38e}{}\index{k\+Buffer.\+c@{k\+Buffer.\+c}!buffer\+Is\+Empty@{buffer\+Is\+Empty}}
\index{buffer\+Is\+Empty@{buffer\+Is\+Empty}!k\+Buffer.\+c@{k\+Buffer.\+c}}
\subsubsection[{buffer\+Is\+Empty}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t buffer\+Is\+Empty (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer}
\end{DoxyParamCaption}
)}\label{k_buffer_8c_a5c599b9386c73ccd7b5eeb25f6cca38e}


Checks, wheter the buffer is empty. 


\begin{DoxyParams}{Parameters}
{\em buffer} & Pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 1} & buffer is empty \\
\hline
{\em 0} & buffer is not empty \\
\hline
\end{DoxyRetVals}
\hypertarget{k_buffer_8c_ac69b8a12a33d0cf0a5dab8feb4f7b020}{}\index{k\+Buffer.\+c@{k\+Buffer.\+c}!buffer\+Is\+Full@{buffer\+Is\+Full}}
\index{buffer\+Is\+Full@{buffer\+Is\+Full}!k\+Buffer.\+c@{k\+Buffer.\+c}}
\subsubsection[{buffer\+Is\+Full}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t buffer\+Is\+Full (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer}
\end{DoxyParamCaption}
)}\label{k_buffer_8c_ac69b8a12a33d0cf0a5dab8feb4f7b020}


Checks, wheter the buffer is full. 


\begin{DoxyParams}{Parameters}
{\em buffer} & Pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 1} & buffer is full \\
\hline
{\em 0} & buffer is not full \\
\hline
\end{DoxyRetVals}
\hypertarget{k_buffer_8c_a1389f5c08210e077301c35bc3b43f681}{}\index{k\+Buffer.\+c@{k\+Buffer.\+c}!buffer\+Mean@{buffer\+Mean}}
\index{buffer\+Mean@{buffer\+Mean}!k\+Buffer.\+c@{k\+Buffer.\+c}}
\subsubsection[{buffer\+Mean}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Mean (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{{\bf buffer\+Datatype} $\ast$}]{mean\+Out}
\end{DoxyParamCaption}
)}\label{k_buffer_8c_a1389f5c08210e077301c35bc3b43f681}


take the average of the whole buffer 


\begin{DoxyParams}{Parameters}
{\em buffer} & pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em mean\+Out} & pointer to a variable, where the mean will be stored \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+O\+K} & it worked as expected, the mean is stored at the given variable \\
\hline
{\em buffer\+Not\+Initialized} & the buffer is not initialized \\
\hline
\end{DoxyRetVals}
\begin{DoxyRefDesc}{Bug}
\item[\hyperlink{bug__bug000001}{Bug}]The sum of the buffer is taken. Take precautions, that this variable won\textquotesingle{}t overflow \end{DoxyRefDesc}
\hypertarget{k_buffer_8c_a1da694b34c0a52809c923d2d149d1348}{}\index{k\+Buffer.\+c@{k\+Buffer.\+c}!buffer\+Mean\+R\+M\+S@{buffer\+Mean\+R\+M\+S}}
\index{buffer\+Mean\+R\+M\+S@{buffer\+Mean\+R\+M\+S}!k\+Buffer.\+c@{k\+Buffer.\+c}}
\subsubsection[{buffer\+Mean\+R\+M\+S}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Mean\+R\+M\+S (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{{\bf buffer\+Datatype} $\ast$}]{mean\+Out}
\end{DoxyParamCaption}
)}\label{k_buffer_8c_a1da694b34c0a52809c923d2d149d1348}


take the root mean square of the whole buffer 


\begin{DoxyParams}{Parameters}
{\em buffer} & pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em mean\+Out} & pointer to a variable, where the mean will be stored \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+O\+K} & it worked as expected, the mean is stored at the given variable \\
\hline
{\em buffer\+Not\+Initialized} & the buffer is not initialized \\
\hline
\end{DoxyRetVals}
\begin{DoxyRefDesc}{Bug}
\item[\hyperlink{bug__bug000002}{Bug}]The sum of squared buffer elements is taken. Take precautions, that this variable won\textquotesingle{}t overflow \end{DoxyRefDesc}
\hypertarget{k_buffer_8c_a9b80be9033ccd6b5a101f811520ab4cc}{}\index{k\+Buffer.\+c@{k\+Buffer.\+c}!buffer\+Read@{buffer\+Read}}
\index{buffer\+Read@{buffer\+Read}!k\+Buffer.\+c@{k\+Buffer.\+c}}
\subsubsection[{buffer\+Read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Read (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{{\bf buffer\+Datatype} $\ast$}]{data}
\end{DoxyParamCaption}
)}\label{k_buffer_8c_a9b80be9033ccd6b5a101f811520ab4cc}


read data from the beginning of the buffer 


\begin{DoxyParams}{Parameters}
{\em buffer} & pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em data} & pointer to a variable where data should be stored \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+O\+K} & it worked as expected \\
\hline
{\em buffer\+Not\+Initialized} & the \hyperlink{k_buffer_8c_aec18d6ea571b1326dbeb7ca15f4969c0}{buffer\+Init()} method hasn\textquotesingle{}t been called or failed before \\
\hline
{\em buffer\+Empty} & the buffer is empty an no more data can be read \\
\hline
\end{DoxyRetVals}
\hypertarget{k_buffer_8c_aa0d7e2a4b6fd3da2822d7f968be74e5c}{}\index{k\+Buffer.\+c@{k\+Buffer.\+c}!buffer\+Read\+From\+Index@{buffer\+Read\+From\+Index}}
\index{buffer\+Read\+From\+Index@{buffer\+Read\+From\+Index}!k\+Buffer.\+c@{k\+Buffer.\+c}}
\subsubsection[{buffer\+Read\+From\+Index}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Read\+From\+Index (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{uint16\+\_\+t}]{index, }
\item[{{\bf buffer\+Datatype} $\ast$}]{data}
\end{DoxyParamCaption}
)}\label{k_buffer_8c_aa0d7e2a4b6fd3da2822d7f968be74e5c}


read data from a specifig index of the buffer W\+A\+R\+N\+I\+N\+G\+: Take care when using this function, it is against the main concept of a ringbuffer 


\begin{DoxyParams}{Parameters}
{\em buffer} & Pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em index} & The index, where data should be written.~\newline
It can be in range 0 to length -\/ 1 \\
\hline
{\em data} & Pointer to a variable where the read data should be written to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+O\+K} & It went successfull \\
\hline
{\em buffer\+Not\+Initialized} & The buffer is not initialized. You have to call buffer\+Init before (or the init failed before) \\
\hline
{\em buffer\+Error} & The desired data index is out of range \\
\hline
\end{DoxyRetVals}
\hypertarget{k_buffer_8c_a9d6410a89adf65a3ef12340ecb9bbd55}{}\index{k\+Buffer.\+c@{k\+Buffer.\+c}!buffer\+Write@{buffer\+Write}}
\index{buffer\+Write@{buffer\+Write}!k\+Buffer.\+c@{k\+Buffer.\+c}}
\subsubsection[{buffer\+Write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Write (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{{\bf buffer\+Datatype}}]{data}
\end{DoxyParamCaption}
)}\label{k_buffer_8c_a9d6410a89adf65a3ef12340ecb9bbd55}


add data to the end of the ringbuffer 


\begin{DoxyParams}{Parameters}
{\em buffer} & pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em data} & data which should be written \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+O\+K} & it worked as expected \\
\hline
{\em buffer\+Not\+Initialized} & the \hyperlink{k_buffer_8c_aec18d6ea571b1326dbeb7ca15f4969c0}{buffer\+Init()} method hasn\textquotesingle{}t been called or failed before \\
\hline
{\em buffer\+Full} & the buffer is full an no more data can be written \\
\hline
\end{DoxyRetVals}
\hypertarget{k_buffer_8c_a8508583be1e356a243b0ce67254c516e}{}\index{k\+Buffer.\+c@{k\+Buffer.\+c}!buffer\+Write\+To\+Index@{buffer\+Write\+To\+Index}}
\index{buffer\+Write\+To\+Index@{buffer\+Write\+To\+Index}!k\+Buffer.\+c@{k\+Buffer.\+c}}
\subsubsection[{buffer\+Write\+To\+Index}]{\setlength{\rightskip}{0pt plus 5cm}{\bf buffer\+Status\+\_\+t} buffer\+Write\+To\+Index (
\begin{DoxyParamCaption}
\item[{{\bf buffer\+\_\+t} $\ast$}]{buffer, }
\item[{uint16\+\_\+t}]{index, }
\item[{{\bf buffer\+Datatype}}]{data}
\end{DoxyParamCaption}
)}\label{k_buffer_8c_a8508583be1e356a243b0ce67254c516e}


write data to a specific index of the buffer. W\+A\+R\+N\+I\+N\+G\+: Take care when using this function, it is against the main concept of a ringbuffer 


\begin{DoxyParams}{Parameters}
{\em buffer} & Pointer to a \hyperlink{structbuffer__t}{buffer\+\_\+t} instance \\
\hline
{\em index} & The index, where data should be written.~\newline
It can be in range 0 to length -\/ 1 \\
\hline
{\em data} & The actual data which should be written \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an element of \hyperlink{k_buffer_8h_a7a0bf550b7bd49d85172e409c0034fe6}{buffer\+Status\+\_\+t} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em buffer\+O\+K} & It went successfull \\
\hline
{\em buffer\+Not\+Initialized} & The buffer is not initialized. You have to call buffer\+Init before (or the init failed before) \\
\hline
{\em buffer\+Error} & The desired data index is out of range \\
\hline
\end{DoxyRetVals}
